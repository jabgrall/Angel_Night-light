<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ange Gabrielle: Adxl345 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ange Gabrielle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classAdxl345-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Adxl345 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="adxl345_8h_source.html">adxl345.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAdxl345_1_1data.html">data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22a48cb41e835b0afbb7030a2ac03ba2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a22a48cb41e835b0afbb7030a2ac03ba2">Adxl345</a> (void)</td></tr>
<tr class="separator:a22a48cb41e835b0afbb7030a2ac03ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec3d3005e4d76127d551076a022f1b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#ac4ec3d3005e4d76127d551076a022f1b">~Adxl345</a> (void)</td></tr>
<tr class="separator:ac4ec3d3005e4d76127d551076a022f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9642148b7cb6c0bb911992d09ecafa85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a9642148b7cb6c0bb911992d09ecafa85">begin</a> ()</td></tr>
<tr class="separator:a9642148b7cb6c0bb911992d09ecafa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61459196504b8288b59baa0b0ad5a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAdxl345_1_1data.html">data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#ad61459196504b8288b59baa0b0ad5a67">getData</a> ()</td></tr>
<tr class="separator:ad61459196504b8288b59baa0b0ad5a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdbeec7e944c90530426a494af8263f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a9bdbeec7e944c90530426a494af8263f">isTape</a> ()</td></tr>
<tr class="separator:a9bdbeec7e944c90530426a494af8263f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b96c1cd115c900190860a378cb5f26b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a3b96c1cd115c900190860a378cb5f26b">isDoubleTap</a> ()</td></tr>
<tr class="separator:a3b96c1cd115c900190860a378cb5f26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a719c4cbda21d18b6cb4fb89de7e82f00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a719c4cbda21d18b6cb4fb89de7e82f00">com</a> (uint8_t addr, bool setWrite, uint8_t nbData)</td></tr>
<tr class="separator:a719c4cbda21d18b6cb4fb89de7e82f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3863be4d6322fce28f034a3fb5459653"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a3863be4d6322fce28f034a3fb5459653">comByte</a> (uint8_t addr, bool setWrite, uint8_t inData=0)</td></tr>
<tr class="separator:a3863be4d6322fce28f034a3fb5459653"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a07bec5c1e0341bee25f4adcebd86ad6c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a07bec5c1e0341bee25f4adcebd86ad6c">bufferIn</a> [<a class="el" href="classAdxl345.html#a6729d8abac6bf4d8ec34d27592dee806">bufferSize</a>]</td></tr>
<tr class="separator:a07bec5c1e0341bee25f4adcebd86ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4a6f06856118367593f108dc4e7041"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#adc4a6f06856118367593f108dc4e7041">bufferOut</a> [<a class="el" href="classAdxl345.html#a6729d8abac6bf4d8ec34d27592dee806">bufferSize</a>]</td></tr>
<tr class="separator:adc4a6f06856118367593f108dc4e7041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a6729d8abac6bf4d8ec34d27592dee806"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAdxl345.html#a6729d8abac6bf4d8ec34d27592dee806">bufferSize</a> = 8</td></tr>
<tr class="separator:a6729d8abac6bf4d8ec34d27592dee806"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a22a48cb41e835b0afbb7030a2ac03ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a48cb41e835b0afbb7030a2ac03ba2">&#9670;&nbsp;</a></span>Adxl345()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Adxl345::Adxl345 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4ec3d3005e4d76127d551076a022f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ec3d3005e4d76127d551076a022f1b">&#9670;&nbsp;</a></span>~Adxl345()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Adxl345::~Adxl345 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9642148b7cb6c0bb911992d09ecafa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9642148b7cb6c0bb911992d09ecafa85">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adxl345::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="adxl345_regs"></a>
REGISTER DEFINITIONS</h1>
<p>From datasheet. Copied in order to keep information during developpement.</p>
<h2><a class="anchor" id="adxl345_regs_31"></a>
Register 0x31—DATA_FORMAT (Read/Write)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td>SELF_TEST </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>SPI </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>INT_INVERT </td><td>0 </td></tr>
<tr>
<td>D4 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D3 </td><td>FULL_RES </td><td>0 </td></tr>
<tr>
<td>D2 </td><td>Justify </td><td>0 </td></tr>
<tr>
<td>D1 </td><td rowspan="2">Range </td><td>0 </td></tr>
<tr>
<td>D0 </td><td>0 </td></tr>
</table>
<p>The DATA_FORMAT register controls the presentation of data to Register 0x32 through Register 0x37. All data, except that for the ±16 g range, must be clipped to avoid rollover.</p>
<h4><a class="anchor" id="adxl345_regs_31_p1"></a>
SELF_TEST Bit</h4>
<p>A setting of 1 in the SELF_TEST bit applies a self-test force to the sensor, causing a shift in the output data. A value of 0 disables the self-test force.</p>
<h4><a class="anchor" id="adxl345_regs_31_p2"></a>
SPI Bit</h4>
<p>A value of 1 in the SPI bit sets the device to 3-wire SPI mode, and a value of 0 sets the device to 4-wire SPI mode.</p>
<h4><a class="anchor" id="adxl345_regs_31_p3"></a>
INT_INVERT</h4>
<p>A value of 0 in the INT_INVERT bit sets the interrupts to active high, and a value of 1 sets the interrupts to active low.</p>
<h4><a class="anchor" id="adxl345_regs_31_p4"></a>
FULL_RES Bit</h4>
<p>When this bit is set to a value of 1, the device is in full resolution mode, where the output resolution increases with the g range set by the range bits to maintain a 4 mg/LSB scale factor. When the FULL_RES bit is set to 0, the device is in 10-bit mode, and the range bits determine the maximum g range and scale factor.</p>
<h4><a class="anchor" id="adxl345_regs_31_p5"></a>
Justify Bit</h4>
<p>A setting of 1 in the justify bit selects left-justified (MSB) mode, and a setting of 0 selects right-justified mode with sign extension.</p>
<h4><a class="anchor" id="adxl345_regs_31_p6"></a>
Range Bits</h4>
<p>These bits set the g range as described in Table 21.</p>
<h4><a class="anchor" id="adxl345_regs_31_p7"></a>
Table 21. g Range Setting</h4>
<table class="doxtable">
<tr>
<th colspan="2">Setting </th><th rowspan="2">g Range </th></tr>
<tr>
<th>D1 </th><th>D0 </th></tr>
<tr>
<td>0 </td><td>0 </td><td>±2 g </td></tr>
<tr>
<td>0 </td><td>1 </td><td>±4 g </td></tr>
<tr>
<td>1 </td><td>0 </td><td>±8 g </td></tr>
<tr>
<td>1 </td><td>1 </td><td>±16 g </td></tr>
</table>
<h2><a class="anchor" id="adxl345_regs_38"></a>
Register 0x38—FIFO_CTL (Read/Write)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td rowspan="2">FIFO_MODE </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>Trigger </td><td>0 </td></tr>
<tr>
<td>D4 </td><td rowspan="5">Samples </td><td>0 </td></tr>
<tr>
<td>D3 </td><td>0 </td></tr>
<tr>
<td>D2 </td><td>0 </td></tr>
<tr>
<td>D1 </td><td>0 </td></tr>
<tr>
<td>D0 </td><td>0 </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_38_p1"></a>
FIFO_TRIG Bit</h4>
<p>These bits set the FIFO mode, as described in Table 22.</p>
<h4><a class="anchor" id="adxl345_regs_38_p2"></a>
Table 22. FIFO Modes</h4>
<table class="doxtable">
<tr>
<th colspan="2">Setting </th><td colspan="2"></td></tr>
<tr>
<th>D7 </th><th>D6 </th><th>Mode </th><th>Function </th></tr>
<tr>
<td>0 </td><td>0 </td><td>Bypass </td><td>FIFO is bypassed. </td></tr>
<tr>
<td>0 </td><td>1 </td><td>FIFO </td><td>FIFO collects up to 32 values and then stops collecting data, collecting new data only when FIFO is not full. </td></tr>
<tr>
<td>1 </td><td>0 </td><td>Stream </td><td>FIFO holds the last 32 data values. When FIFO is full, the oldest data is overwritten with newer data. </td></tr>
<tr>
<td>1 </td><td>1 </td><td>Trigger </td><td>When triggered by the trigger bit, FIFO holds the last data samples before the trigger event and then continues to collect data until full. New data is collected only when FIFO is not full. </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_38_p3"></a>
Trigger Bit</h4>
<p>A value of 0 in the trigger bit links the trigger event of trigger mode to INT1, and a value of 1 links the trigger event to INT2.</p>
<h4><a class="anchor" id="adxl345_regs_38_p4"></a>
Samples Bits</h4>
<p>The function of these bits depends on the FIFO mode selected (see Table 23). Entering a value of 0 in the samples bits immediately sets the watermark status bit in the INT_SOURCE register, regardless of which FIFO mode is selected. Undesirable operation may occur if a value of 0 is used for the samples bits when trigger mode is used.</p>
<h4><a class="anchor" id="adxl345_regs_38_p5"></a>
Table 23. Samples Bits Functions</h4>
<table class="doxtable">
<tr>
<th>FIFO Mode </th><th>Samples Bits Function </th></tr>
<tr>
<td>Bypass </td><td>None. </td></tr>
<tr>
<td>FIFO </td><td>Specifies how many FIFO entries are needed to trigger a watermark interrupt. </td></tr>
<tr>
<td>Stream </td><td>Specifies how many FIFO entries are needed to trigger a watermark interrupt. </td></tr>
<tr>
<td>Trigger </td><td>Specifies how many FIFO samples are retained in the FIFO buffer before a trigger event. </td></tr>
</table>
<h2><a class="anchor" id="adxl345_regs_1E1F20"></a>
Register 0x1E, Register 0x1F, Register 0x20—OFSX, OFSY, OFSZ (Read/Write)</h2>
<p>The OFSX, OFSY, and OFSZ registers are each eight bits and offer user-set offset adjustments in twos complement format with a scale factor of 15.6 mg/LSB (that is, 0x7F = 2 g). The value stored in the offset registers is automatically added to the acceleration data, and the resulting value is stored in the output data registers. For additional information regarding offset calibration and the use of the offset registers, refer to the Offset Calibration section.</p>
<h2><a class="anchor" id="adxl345_regs_2C"></a>
Register 0x2C—BW_RATE (Read/Write)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D4 </td><td>LOW_POWER </td><td>0 </td></tr>
<tr>
<td>D3 </td><td rowspan="4">Rate </td><td>1 </td></tr>
<tr>
<td>D2 </td><td>0 </td></tr>
<tr>
<td>D1 </td><td>1 </td></tr>
<tr>
<td>D0 </td><td>0 </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_2C_p1"></a>
LOW_POWER Bit</h4>
<p>A setting of 0 in the LOW_POWER bit selects normal operation, and a setting of 1 selects reduced power operation, which has somewhat higher noise (see the Power Modes section for details).</p>
<h4><a class="anchor" id="adxl345_regs_2C_p2"></a>
Rate Bits</h4>
<p>These bits select the device bandwidth and output data rate (see Table 7 and Table 8 for details). The default value is 0x0A, which translates to a 100 Hz output data rate. An output data rate should be selected that is appropriate for the communication protocol and frequency selected. Selecting too high of an output data rate with a low communication speed results in samples being discarded.</p>
<h2><a class="anchor" id="adxl345_regs_1D"></a>
Register 0x1D—THRESH_TAP (Read/Write)</h2>
<p>The THRESH_TAP register is eight bits and holds the threshold value for tap interrupts. The data format is unsigned, therefore, the magnitude of the tap event is compared with the value in THRESH_TAP for normal tap detection. The scale factor is 62.5 mg/LSB (that is, 0xFF = 16 g). A value of 0 may result in undesirable behavior if single tap/double tap interrupts are enabled.</p>
<h2><a class="anchor" id="adxl345_regs_21"></a>
Register 0x21—DUR (Read/Write)</h2>
<p>The DUR register is eight bits and contains an unsigned time value representing the maximum time that an event must be above the THRESH_TAP threshold to qualify as a tap event. The scale factor is 625 μs/LSB. A value of 0 disables the single tap/ double tap functions.</p>
<h2><a class="anchor" id="adxl345_regs_22"></a>
Register 0x22—Latent (Read/Write)</h2>
<p>The latent register is eight bits and contains an unsigned time value representing the wait time from the detection of a tap event to the start of the time window (defined by the window register) during which a possible second tap event can be detected. The scale factor is 1.25 ms/LSB. A value of 0 disables the double tap function.</p>
<h2><a class="anchor" id="adxl345_regs_23"></a>
Register 0x23—Window (Read/Write)</h2>
<p>The window register is eight bits and contains an unsigned time value representing the amount of time after the expiration of the latency time (determined by the latent register) during which a second valid tap can begin. The scale factor is 1.25 ms/LSB. A value of 0 disables the double tap function.</p>
<h2><a class="anchor" id="adxl345_regs_2A"></a>
Register 0x2A—TAP_AXES (Read/Write)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D4 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D3 </td><td>Suppress </td><td>0 </td></tr>
<tr>
<td>D2 </td><td>TAP_X enable </td><td>0 </td></tr>
<tr>
<td>D1 </td><td>TAP_Y enable </td><td>0 </td></tr>
<tr>
<td>D0 </td><td>TAP_Z enable </td><td>0 </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_2A_p1"></a>
Suppress Bit</h4>
<p>Setting the suppress bit suppresses double tap detection if acceleration greater than the value in THRESH_TAP is present between taps. See the Tap Detection section for more details.</p>
<h4><a class="anchor" id="adxl345_regs_2A_p2"></a>
TAP_x Enable Bits</h4>
<p>A setting of 1 in the TAP_X enable, TAP_Y enable, or TAP_Z enable bit enables x-, y-, or z-axis participation in tap detection. A setting of 0 excludes the selected axis from participation in tap detection.</p>
<h2><a class="anchor" id="adxl345_regs_27"></a>
Register 0x27—ACT_INACT_CTL (Read/Write)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td>ACT ac/dc </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>ACT_X enable </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>ACT_Y enable </td><td>0 </td></tr>
<tr>
<td>D4 </td><td>ACT_Z enable </td><td>0 </td></tr>
<tr>
<td>D3 </td><td>INACT ac/dc </td><td>0 </td></tr>
<tr>
<td>D2 </td><td>INACT_X enable </td><td>0 </td></tr>
<tr>
<td>D1 </td><td>INACT_Y enable </td><td>0 </td></tr>
<tr>
<td>D0 </td><td>INACT_Z enable </td><td>0 </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_27_p1"></a>
ACT AC/DC and INACT AC/DC Bits</h4>
<p>A setting of 0 selects dc-coupled operation, and a setting of 1 enables ac-coupled operation. In dc-coupled operation, the current acceleration magnitude is compared directly with THRESH_ACT and THRESH_INACT to determine whether activity or inactivity is detected.</p>
<p>In ac-coupled operation for activity detection, the acceleration value at the start of activity detection is taken as a reference value. New samples of acceleration are then compared to this reference value, and if the magnitude of the difference exceeds the THRESH_ACT value, the device triggers an activity interrupt. Similarly, in ac-coupled operation for inactivity detection, a reference value is used for comparison and is updated whenever the device exceeds the inactivity threshold. After the reference value is selected, the device compares the magnitude of the difference between the reference value and the current acceleration with THRESH_INACT. If the difference is less than the value in THRESH_INACT for the time in TIME_INACT, the device is considered inactive and the inactivity interrupt is triggered.</p>
<h4><a class="anchor" id="adxl345_regs_27_p2"></a>
ACT_x Enable Bits and INACT_x Enable Bits</h4>
<p>A setting of 1 enables x-, y-, or z-axis participation in detecting activity or inactivity. A setting of 0 excludes the selected axis from participation. If all axes are excluded, the function is disabled. For activity detection, all participating axes are logically OR’ed, causing the activity function to trigger when any of the partici- pating axes exceeds the threshold. For inactivity detection, all participating axes are logically AND’ed, causing the inactivity function to trigger only if all participating axes are below the threshold for the specified time.</p>
<h2><a class="anchor" id="adxl345_regs_24"></a>
Register 0x24—THRESH_ACT (Read/Write)</h2>
<p>The THRESH_ACT register is eight bits and holds the threshold value for detecting activity. The data format is unsigned, so the magnitude of the activity event is compared with the value in the THRESH_ACT register. The scale factor is 62.5 mg/LSB. A value of 0 may result in undesirable behavior if the activity interrupt is enabled.</p>
<h2><a class="anchor" id="adxl345_regs_25"></a>
Register 0x25—THRESH_INACT (Read/Write)</h2>
<p>The THRESH_INACT register is eight bits and holds the threshold value for detecting inactivity. The data format is unsigned, so the magnitude of the inactivity event is compared with the value in the THRESH_INACT register. The scale factor is 62.5 mg/LSB. A value of 0 may result in undesirable behavior if the inactivity interrupt is enabled.</p>
<h2><a class="anchor" id="adxl345_regs_26"></a>
Register 0x26—TIME_INACT (Read/Write)</h2>
<p>The TIME_INACT register is eight bits and contains an unsigned time value representing the amount of time that acceleration must be less than the value in the THRESH_INACT register for inactivity to be declared. The scale factor is 1 sec/LSB. Unlike the other interrupt functions, which use unfiltered data (see the Threshold section), the inactivity function uses filtered output data. At least one output sample must be generated for the inactivity interrupt to be triggered. This results in the function appearing unresponsive if the TIME_INACT register is set to a value less than the time constant of the output data rate. A value of 0 results in an interrupt when the output data is less than the value in the THRESH_INACT register.</p>
<h2><a class="anchor" id="adxl345_regs_28"></a>
Register 0x28—THRESH_FF (Read/Write) LOW_POWER Bit</h2>
<p>The THRESH_FF register is eight bits and holds the threshold value, in unsigned format, for free-fall detection. The acceleration on all axes is compared with the value in THRESH_FF to determine if a free-fall event occurred. The scale factor is 62.5 mg/LSB. Note that a value of 0 mg may result in undesirable behavior if the free- fall interrupt is enabled. Values between 300 mg and 600 mg (0x05 to 0x09) are recommended.</p>
<h2><a class="anchor" id="adxl345_regs_29"></a>
Register 0x29—TIME_FF (Read/Write)</h2>
<p>The TIME_FF register is eight bits and stores an unsigned time value representing the minimum time that the value of all axes must be less than THRESH_FF to generate a free-fall interrupt. The scale factor is 5 ms/LSB. A value of 0 may result in undesirable behavior if the free-fall interrupt is enabled. Values between 100 ms and 350 ms (0x14 to 0x46) are recommended.</p>
<h2><a class="anchor" id="adxl345_regs_2F"></a>
Register 0x2F—INT_MAP (R/W)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td>DATA_READY </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>SINGLE_TAP </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>DOUBLE_TAP </td><td>0 </td></tr>
<tr>
<td>D4 </td><td>Activity </td><td>0 </td></tr>
<tr>
<td>D3 </td><td>Inactivity </td><td>0 </td></tr>
<tr>
<td>D2 </td><td>FREE_FALL </td><td>0 </td></tr>
<tr>
<td>D1 </td><td>Watermark </td><td>0 </td></tr>
<tr>
<td>D0 </td><td>Overrun </td><td>0 </td></tr>
</table>
<p>Any bits set to 0 in this register send their respective interrupts to the INT1 pin, whereas bits set to 1 send their respective interrupts to the INT2 pin. All selected interrupts for a given pin are OR’ed.</p>
<h2><a class="anchor" id="adxl345_regs_2E"></a>
Register 0x2E—INT_ENABLE (Read/Write)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td>DATA_READY </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>SINGLE_TAP </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>DOUBLE_TAP </td><td>0 </td></tr>
<tr>
<td>D4 </td><td>Activity </td><td>0 </td></tr>
<tr>
<td>D3 </td><td>Inactivity </td><td>0 </td></tr>
<tr>
<td>D2 </td><td>FREE_FALL </td><td>0 </td></tr>
<tr>
<td>D1 </td><td>Watermark </td><td>0 </td></tr>
<tr>
<td>D0 </td><td>Overrun </td><td>0 </td></tr>
</table>
<p>Setting bits in this register to a value of 1 enables their respective functions to generate interrupts, whereas a value of 0 prevents the functions from generating interrupts. The DATA_READY, watermark, and overrun bits enable only the interrupt output; the functions are always enabled. It is recommended that interrupts be configured before enabling their outputs.</p>
<h2><a class="anchor" id="adxl345_regs_2D"></a>
Register 0x2D—POWER_CTL (Read/Write)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th><th>Choosen value </th></tr>
<tr>
<td>D7 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>0 </td><td>0 </td></tr>
<tr>
<td>D5 </td><td>Link </td><td>0 </td></tr>
<tr>
<td>D4 </td><td>AUTO_SLEEP </td><td>0 </td></tr>
<tr>
<td>D3 </td><td>Measure </td><td>1 </td></tr>
<tr>
<td>D2 </td><td>Sleep </td><td>0 </td></tr>
<tr>
<td>D1 </td><td rowspan="2">Wakeup </td><td>0 </td></tr>
<tr>
<td>D0 </td><td>0 </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_2D_p1"></a>
Link Bit</h4>
<p>A setting of 1 in the link bit with both the activity and inactivity functions enabled delays the start of the activity function until inactivity is detected. After activity is detected, inactivity detection begins, preventing the detection of activity. This bit serially links the activity and inactivity functions. When this bit is set to 0, the inactivity and activity functions are concurrent. Additional information can be found in the Link Mode section.</p>
<p>When clearing the link bit, it is recommended that the part be placed into standby mode and then set back to measurement mode with a subsequent write. This is done to ensure that the device is properly biased if sleep mode is manually disabled; otherwise, the first few samples of data after the link bit is cleared may have additional noise, especially if the device was asleep when the bit was cleared.</p>
<h4><a class="anchor" id="adxl345_regs_2D_p2"></a>
AUTO_SLEEP Bit</h4>
<p>If the link bit is set, a setting of 1 in the AUTO_SLEEP bit enables the auto-sleep functionality. In this mode, the ADXL345 auto- matically switches to sleep mode if the inactivity function is enabled and inactivity is detected (that is, when acceleration is below the THRESH_INACT value for at least the time indicated by TIME_INACT). If activity is also enabled, the ADXL345 automatically wakes up from sleep after detecting activity and returns to operation at the output data rate set in the BW_RATE register. A setting of 0 in the AUTO_SLEEP bit disables automatic switching to sleep mode. See the description of the Sleep Bit in this section for more information on sleep mode.</p>
<p>If the link bit is not set, the AUTO_SLEEP feature is disabled and setting the AUTO_SLEEP bit does not have an impact on device operation. Refer to the Link Bit section or the Link Mode section for more information on utilization of the link feature.</p>
<p>When clearing the AUTO_SLEEP bit, it is recommended that the part be placed into standby mode and then set back to measure- ment mode with a subsequent write. This is done to ensure that the device is properly biased if sleep mode is manually disabled; otherwise, the first few samples of data after the AUTO_SLEEP bit is cleared may have additional noise, especially if the device was asleep when the bit was cleared.</p>
<h4><a class="anchor" id="adxl345_regs_2D_p3"></a>
Measure Bit</h4>
<p>A setting of 0 in the measure bit places the part into standby mode, and a setting of 1 places the part into measurement mode. The ADXL345 powers up in standby mode with minimum power consumption.</p>
<h4><a class="anchor" id="adxl345_regs_2D_p4"></a>
Sleep Bit</h4>
<p>A setting of 0 in the sleep bit puts the part into the normal mode of operation, and a setting of 1 places the part into sleep mode. Sleep mode suppresses DATA_READY, stops transmission of data to FIFO, and switches the sampling rate to one specified by the wakeup bits. In sleep mode, only the activity function can be used. When the DATA_READY interrupt is suppressed, the output data registers (Register 0x32 to Register 0x37) are still updated at the sampling rate set by the wakeup bits (D1:D0).</p>
<p>When clearing the sleep bit, it is recommended that the part be placed into standby mode and then set back to measurement mode with a subsequent write. This is done to ensure that the device is properly biased if sleep mode is manually disabled; otherwise, the first few samples of data after the sleep bit is cleared may have additional noise, especially if the device was asleep when the bit was cleared.</p>
<h4><a class="anchor" id="adxl345_regs_2D_p5"></a>
Wakeup Bits</h4>
<p>These bits control the frequency of readings in sleep mode as described in Table 20.</p>
<h4><a class="anchor" id="adxl345_regs_2D_p6"></a>
Table 20. Frequency of Readings in Sleep Mode</h4>
<table class="doxtable">
<tr>
<th colspan="2">Setting </th><td></td></tr>
<tr>
<th>D1 </th><th>D0 </th><th>Frequency (Hz) </th></tr>
<tr>
<th>0 </th><td>0 </td><td>8 </td></tr>
<tr>
<th>0 </th><td>1 </td><td>4 </td></tr>
<tr>
<th>1 </th><td>0 </td><td>2 </td></tr>
<tr>
<th>1 </th><td>1 </td><td>1 </td></tr>
</table>
<h2><a class="anchor" id="adxl345_regs_32-37"></a>
Register 0x32 to Register 0x37—DATAX0, DATAX1, DATAY0, DATAY1, DATAZ0, DATAZ1 (Read Only)</h2>
<p>These six bytes (Register 0x32 to Register 0x37) are eight bits each and hold the output data for each axis. Register 0x32 and Register 0x33 hold the output data for the x-axis, Register 0x34 and Register 0x35 hold the output data for the y-axis, and Register 0x36 and Register 0x37 hold the output data for the z-axis. The output data is twos complement, with DATAx0 as the least significant byte and DATAx1 as the most significant byte, where x represent X, Y, or Z. The DATA_FORMAT register (Address 0x31) controls the format of the data. It is recommended that a multiple-byte read of all registers be performed to prevent a change in data between reads of sequential registers.</p>
<h2><a class="anchor" id="adxl345_regs_00"></a>
Register 0x00—DEVID (Read Only)</h2>
<p>The DEVID register holds a fixed device ID code of 0xE5 (345 octal).</p>
<h2><a class="anchor" id="adxl345_regs_39"></a>
Register 0x39—FIFO_STATUS (Read Only)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th></tr>
<tr>
<td>D7 </td><td>FIFO_TRIG </td></tr>
<tr>
<td>D6 </td><td>0 </td></tr>
<tr>
<td>D5 </td><td rowspan="6">Entries </td></tr>
<tr>
<td>D4 </td></tr>
<tr>
<td>D3 </td></tr>
<tr>
<td>D2 </td></tr>
<tr>
<td>D1 </td></tr>
<tr>
<td>D0 </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_39_p1"></a>
FIFO_MODE Bits</h4>
<p>A 1 in the FIFO_TRIG bit corresponds to a trigger event occurring, and a 0 means that a FIFO trigger event has not occurred.</p>
<h4><a class="anchor" id="adxl345_regs_39_p2"></a>
Entries Bits</h4>
<p>These bits report how many data values are stored in FIFO. Access to collect the data from FIFO is provided through the DATAX, DATAY, and DATAZ registers. FIFO reads must be done in burst or multiple-byte mode because each FIFO level is cleared after any read (single- or multiple-byte) of FIFO. FIFO stores a maximum of 32 entries, which equates to a maximum of 33 entries available at any given time because an additional entry is available at the output filter of the device.</p>
<h2><a class="anchor" id="adxl345_regs_2B"></a>
Register 0x2B—ACT_TAP_STATUS (Read Only)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th></tr>
<tr>
<td>D7 </td><td>0 </td></tr>
<tr>
<td>D6 </td><td>ACT_X source </td></tr>
<tr>
<td>D5 </td><td>ACT_Y source </td></tr>
<tr>
<td>D4 </td><td>ACT_Z source </td></tr>
<tr>
<td>D3 </td><td>Asleep </td></tr>
<tr>
<td>D2 </td><td>TAP_X source </td></tr>
<tr>
<td>D1 </td><td>TAP_Y source </td></tr>
<tr>
<td>D0 </td><td>TAP_Z source </td></tr>
</table>
<h4><a class="anchor" id="adxl345_regs_2B_p1"></a>
ACT_x Source and TAP_x Source Bits</h4>
<p>These bits indicate the first axis involved in a tap or activity event. A setting of 1 corresponds to involvement in the event, and a setting of 0 corresponds to no involvement. When new data is available, these bits are not cleared but are overwritten by the new data. The ACT_TAP_STATUS register should be read before clearing the interrupt. Disabling an axis from participation clears the corresponding source bit when the next activity or single tap/double tap event occurs.</p>
<h4><a class="anchor" id="adxl345_regs_2B_p2"></a>
Asleep Bit</h4>
<p>A setting of 1 in the asleep bit indicates that the part is asleep, and a setting of 0 indicates that the part is not asleep. This bit toggles only if the device is configured for auto sleep. See the AUTO_SLEEP Bit section for more information on autosleep mode.</p>
<h2><a class="anchor" id="adxl345_regs_30"></a>
Register 0x30—INT_SOURCE (Read Only)</h2>
<table class="doxtable">
<tr>
<th>Bits </th><th>Function </th></tr>
<tr>
<td>D7 </td><td>DATA_READY </td></tr>
<tr>
<td>D6 </td><td>SINGLE_TAP </td></tr>
<tr>
<td>D5 </td><td>DOUBLE_TAP </td></tr>
<tr>
<td>D4 </td><td>Activity </td></tr>
<tr>
<td>D3 </td><td>Inactivity </td></tr>
<tr>
<td>D2 </td><td>FREE_FALL </td></tr>
<tr>
<td>D1 </td><td>Watermark </td></tr>
<tr>
<td>D0 </td><td>Overrun </td></tr>
</table>
<p>Bits set to 1 in this register indicate that their respective functions have triggered an event, whereas a value of 0 indicates that the corresponding event has not occurred. The DATA_READY, watermark, and overrun bits are always set if the corresponding events occur, regardless of the INT_ENABLE register settings, and are cleared by reading data from the DATAX, DATAY, and DATAZ registers. The DATA_READY and watermark bits may require multiple reads, as indicated in the FIFO mode descriptions in the FIFO section. Other bits, and the corresponding interrupts, are cleared by reading the INT_SOURCE register.</p>

</div>
</div>
<a id="a719c4cbda21d18b6cb4fb89de7e82f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719c4cbda21d18b6cb4fb89de7e82f00">&#9670;&nbsp;</a></span>com()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adxl345::com </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nbData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3863be4d6322fce28f034a3fb5459653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3863be4d6322fce28f034a3fb5459653">&#9670;&nbsp;</a></span>comByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Adxl345::comByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>inData</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad61459196504b8288b59baa0b0ad5a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61459196504b8288b59baa0b0ad5a67">&#9670;&nbsp;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAdxl345_1_1data.html">Adxl345::data</a> Adxl345::getData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b96c1cd115c900190860a378cb5f26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b96c1cd115c900190860a378cb5f26b">&#9670;&nbsp;</a></span>isDoubleTap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Adxl345::isDoubleTap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bdbeec7e944c90530426a494af8263f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdbeec7e944c90530426a494af8263f">&#9670;&nbsp;</a></span>isTape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Adxl345::isTape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a07bec5c1e0341bee25f4adcebd86ad6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bec5c1e0341bee25f4adcebd86ad6c">&#9670;&nbsp;</a></span>bufferIn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Adxl345::bufferIn[<a class="el" href="classAdxl345.html#a6729d8abac6bf4d8ec34d27592dee806">bufferSize</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc4a6f06856118367593f108dc4e7041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4a6f06856118367593f108dc4e7041">&#9670;&nbsp;</a></span>bufferOut</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Adxl345::bufferOut[<a class="el" href="classAdxl345.html#a6729d8abac6bf4d8ec34d27592dee806">bufferSize</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6729d8abac6bf4d8ec34d27592dee806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6729d8abac6bf4d8ec34d27592dee806">&#9670;&nbsp;</a></span>bufferSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t Adxl345::bufferSize = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/ADXL345/<a class="el" href="adxl345_8h_source.html">adxl345.h</a></li>
<li>lib/ADXL345/<a class="el" href="adxl345_8cxx.html">adxl345.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
